# Section 0

## 0.1. 学习算法和刷题的框架思维

### 0.1.1. 数据结构的存储方式

- 最底层只有两种: 数组和链表. (插入/删除, 查找)

### 0.1.2. 数据结构的基本操作

- 遍历 + 访问
    - 线性: e.g. 遍历
    - 非线性: e.g. 递归 (链表; 二叉树...)

### 0.1.3. 算法刷题指南

- 问题 <-> 数据结构 <-> 代码**框架**
- 为什么要先刷二叉树呢，**因为二叉树是最容易培养框架思维的，而且大部分算法技巧，本质上都是树的遍历问题**。

## 0.2. 动态规划解题框架

- 动态规划: 求最值时避免重复的穷举.

- 动态规划三要素: 

    - 重叠子问题; (暴力时一个子问题会被多次计算)
    - 最优子结构; (不同子问题之间相互独立)
    - 状态转移方程.

- **明确 base case -> 明确「状态」-> 明确「选择」 -> 定义 dp 数组/函数的含义**。

    - 状态: 原问题和子问题中会变化的变量

    - 选择: 导致「状态」产生变化的行为

    -  dp 数组/函数的含义: 递归 / 递推

    - ```python
        # 初始化 base case
        dp[0][0][...] = base
        # 进行状态转移
        for 状态1 in 状态1的所有取值：
            for 状态2 in 状态2的所有取值：
                for ...
                    dp[状态1][状态2][...] = 求最值(选择1，选择2...)
        ```

### 0.2.1. 斐波那契数列

- `递归的时间复杂度`: 子问题的个数(递归树中的节点个数) * 解决每一个子问题需要的时间(假设它所需要的子节点已经算出)

- 三种动态规划解法:

- `解法1`: 暴力

    - base case + 子问题 (状态/选择) + 状态转移方程

- `解法2`: 带备忘录的递归解法; [自顶向下]

    - 相当于给递归树剪枝

- `解法3`: 递推算法 [自底向上]

    - 相当于沿着剪了枝的递归树从下往上递推上去的
    - 重叠子问题.

    - 状态转移方程(暴力中需要的); 状态压缩(仅记录所需状态).

### 0.2.2. 凑零钱

- 注: 若零钱个数有限则不满足最优子结构了, 因为不同子问题之间会影响.

- 注意处理子问题无解的情况.

- 使用`递推算法`时也可以用`递归`的想法:

    - ```
        # 递推 && 递归思想
        for i in range(状态):
        	dp[i] = f(dp[子问题状态])
        	
        # 递推 && 递推思想
        for i in range(状态):
        	dp[i的父问题] = f(dp[i])
        ```

## 0.3. 回溯算法解题框架

- **解决一个回溯问题，实际上就是一个决策树的遍历过程**。

    - 路径 (当前行走的路径); 分支(当前节点的子节点); 结束条件(到达叶子节点)

    - ```python
        result = []
        def backtrack(路径, 选择列表):
            if 满足结束条件:
                result.add(路径)
                return
        
            for 选择 in 选择列表:
                做选择
                backtrack(路径, 选择列表)
                撤销选择
        ```

- **前序遍历的代码在进入某一个节点之前的那个时间点执行，后序遍历代码在离开某个节点之后的那个时间点执行**。

- 不一定非得到结束条件才停止下钻, 中途可以加入`isValid`判断当前路径是否已经非法从而实现剪枝.

- 全排列:

    - 可以将数组分为两个部分: 已经填过和未填过, 这样只需要交换.

#### 0.3.1. Compared between DP and Backtrack

- 本质都是一颗递归树:
    - DP: 基于重复子问题; 最优子结构, 减少对子树(子问题)的遍历.
    - Backtrack: 先序遍历递归树, 问题之间(树和子树)之间**不满足**最优子结构. (父节点会修改子树可用的选择列表.)
        - 可以利用题目的一些限制进行剪枝. (`isValid`)

## 0.4. BFS算法解题框架

```c++
初始化队列Q.
Q={起点s}; 
标记s为己访问; // 1.
while (Q非空) {
    取Q队首元素u; u出队;
    if (u == 目标状态) {…} // 2.
    所有与u相邻且未被访问的点进入队列;  // 3.
    标记与u相邻的点为已访问;
}
```

- 既然 BFS 那么好，为啥 DFS 还要存在**？

> BFS 可以找到最短距离，但是*空间复杂度高，而 DFS 的空间复杂度较低*。
>
> 还是拿刚才我们处理二叉树问题的例子，假设给你的这个二叉树是满二叉树，节点数为 `N`，对于 DFS 算法来说，空间复杂度无非就是递归堆栈，最坏情况下顶多就是树的高度，也就是 `O(logN)`。
>
> 但是你想想 BFS 算法，队列中每次都会储存着二叉树一层的节点，这样的话最坏情况下空间复杂度应该是树的最底层节点的数量，也就是 `N/2`，用 Big O 表示的话也就是 `O(N)`。
>
> 由此观之，BFS 还是有代价的，一般来说在找最短路径的时候使用 BFS，其他时候还是 DFS 使用得多一些.

- 如果BFS需要返回的是步数, 则一般需要`queue<pair<node, int>>`.
- 

### 0.4.1. 双向 BFS 优化

- 传统BFS: 起点->终点; 双向BFS: 起点->终点 and 终点->起点.

    - 二者最坏复杂度都是 `O(N)`，但是实际上双向 BFS 确实会快一些

    - <img src="../pic/DBFS1.png" alt="img" style="zoom:25%;" /> <img src="../pic/DBFS2.png" alt="img" style="zoom:25%;" />

    - 双向 BFS 也有局限，因为你必须知道终点在哪里.

    - 实现技巧:

        - **不再使用队列，而是使用 HashSet 方便快速判断两个集合是否有交集**。

        - 另外的一个技巧点就是 **while 循环的最后交换** **`start1`** **和** **`start2`** **的内容**，所以只要默认扩散 `start1` 就相当于轮流扩散 `start1` 和 `start2`。

        - 双向BFS中, 不能在入队时把所有元素都加入`visited`, 不然两个集合永远不会有交集了. (而是在出队)

            - 但因为这样, 集合中会存在重复入队的元素, 所以不用queue用set.
            - 同时注意这种写法, 相当于每次扩散是扩散了**一层** (for循环), 而不是单向
                BFS扩散一个节点.

        - 始终扩散临接元素较小的集合:

            - ```c++
                set<Node> start1;
                set<Node> start2;
                start1.push(start);
                start2.push(end);
                hash_map<Node> visited;
                
                while (!start1.isEmpty() && !start2.isEmpty()) {
                    // 优化 optional
                    if (start1.size() > start2.size()) {
                        // 交换 start1 和 start2
                        temp = start1;
                        start1 = start2;
                        start2 = temp;
                    }
                    // set在循环时不能修改
                    set<Node> tmpt;
                    
                    for(start1的所有节点p) {
                        // 出队时标记已经访问
                        visited.add(p);
                        if (start2.contains(p)) {目标节点...}
                        for(p的所有未访问的邻居节点n)
                            tmpt.add(n);
                    }
                    start1 = start2;
                    start2 = temp;
                }
                ```

            - 因为按照 BFS 的逻辑，**队列（集合）中的元素越多，扩散之后新的队列（集合）中的元素就越多**；在双向 BFS 算法中，如果我们每次都选择一个较小的集合进行扩散，那么占用的空间增长速度就会慢一些，效率就会高一些

## 0.5. 二分搜索

- 见自己的`板子.md`

## 0.6. 滑动窗口

TODO